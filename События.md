Events are basically programmable [node systems](./Nodes) that allows you to program logic for your adventure maps without writing any scripts or code. The way it works is you have multiple types of nodes at your disposal that you can create logic with them. Connecting these nodes together can produce a meaningful *program* that can do something with the world, player, NPCs and etc.

Events can be triggered either from [triggers](./Trigger) or via `/mp event trigger` [command](https://github.com/mchorse/mappet/wiki/Commands#event-commands).

Events can be managed in [Mappet dashboard](./Mappet-dashboard). The third panel in the left sidebar opens event editor.

## Editing

Once you pick or create an event, you'd see an editor like this:

![Node editor](https://i.imgur.com/A5iJmJf.png)

Event system supports following types of nodes:

* **Command** node allows to execute commands, and depending on the result of command execution direct the flow
* **Condition** node allows to check an [expression](./Expressions), and depending on the evaluated result of the expression direct the flow
* **Switch** node allows to direct the execution flow depending on the output of the given [expression](./Expressions)
* **Timer** node allows to delay the execution

### Command node

Command node executes a command from the perspective of the subject that triggered it. The subject could be a player, if the event was triggered through `/mp event trigger`, trigger block, or a region block, or an [NPC](./NPCs) if it was triggered from one of the NPC triggers.

Beside that, commands within command node can use special formatting to evaluate an [expression](./Expressions) within `${...}`. For example, if you want to use `/setblock` command to put a block, however, you want it to place a fire block during the night, but stone block during the day. To do that, you can simply input following command:

```
/setblock -1514 4 1981 minecraft:${world_is_day() ? "stone" : "fire"}
```

And it will replace the `${world_is_day() ? "stone" : "fire"}` depending on what time of the day it is. I.e. fire during the night, and stone during the day. Also, if you ever need to reference the subject player/NPC in commands, you can use `${subject}` expression (which is UUID of the subject entity) which works with all commands that provide target selector arguments.

When command gets executed, if there was no error, then it will pass the execution to all of its input (child) nodes. However, if the command errored, then it will won't continue the execution. **Binary** toggle allows to change this behavior. Instead of all on success, or none on failure, binary instead works like this: on success it will pass the execution to the first node (denoted by `0` and green flow), while on error it will pass the execution to the second node (denoted by `1` and red flow). All other connected nodes will be **ignored** (as depicted by node `2` with yellow semitransparent flow).

![Binary mode in action](https://i.imgur.com/cdrc8bU.png)

### Нод "Условие"

Нод "Условие" оценивает своё [выражение](./Выражения.md), и, в зависимости от полученного значения, передаёт исполнение дальше. Если получившееся значение не равняется нулю (всё кроме `0`), то нод передаст исполнение всем соединённым (дочерним) нодам. Если полученное значени равняется `0`, то ни один нод не будет исполнен. Также, как и с нодом "Команда", переключатель **Бинарный** позволяет сменить модель исполнения нодов с все-либо-никто на первый-либо-второй.

Используя опцию бинарности, вы можете создать выражение типа `if-elseif-else` (либо-или же либо - или же) вот таким образом:

![Исполнение if-elseif-else](https://i.imgur.com/LN7FpUq.png)

### Нод "Переключатель"

Нод "Переключатель" похож на нод "Условие", только вместо передачи исполнения по механизму все-либо-никто или бинарной модели, он оценивает собственное [выражение](./Выражения.md), и передаёт исполнение дочернему ноду с индексом получившегося значения. К примеру, скажем вы хотите случайно передать исполнение одному из трёх нодов типа "Команда". Этого можно добиться посредством ввода `floor(random(0, 3))` в нод "Переключатель", тогда у вас выйдет что-то в роде того:

![Случайное исполнение](https://i.imgur.com/xbnrp9B.png)

### Нод "Таймер"

Нод "Таймер" позволяет задержать исполнение системы нодов на заданное количество тиков. Если вы хотите исполнять команды постепенно, вы можете использовать этот нод, дабы задерживать команды.

## Иерархия

Касаемо иерархии никаких ограничений нет, как и касаемо того, в каком порядке необходимо организовывать нолы, однако, дабы инициализировать нод "Событие", вам необходимо указать главный нод, как это было описано на [странице Нодов](./Ноды.md#пометка-нода-главным).

## Передача пользовательских данных

У [команды](./Команды.md#mp-event-trigger-target-id-data) `/mp event trigger` есть опциональный аргумент под названием `[data]` (данные). Через него вы можете передавать опциональные данные NBT, которые будут использованы в событии. К примеру, скажем у нас в событии есть нод "Переключатель", которым нужно управлять со стороны, что-то в таком роде:

![Пользовательская переменная](https://i.imgur.com/ORa6Z5O.png)

Так что, теперь можно пределать переменную используя последний аргумент посредством NBT вот таким образом:

```
/mp event trigger @r fire {input:2}
```

Эта команда передаст в `input` значение `2`, что, по принципу действия нода "Переключатель", передаст выполнение ноду с индексом `2` (самый правый). В графу `[data]` вы можете вводить только нумерические значения и строки. Комплексные тэги и тэги-списки **не поддерживаются**!
